{
  "version": 3,
  "sources": ["../src/helpers/create-directive.ts", "../src/directives/get-ref.ts", "../src/helpers/update-element-attrs.ts", "../src/directives/updatable-attrs.ts", "../src/helpers/update-node.ts", "../src/directives/updatable-node.ts"],
  "sourcesContent": ["import type { TemplateArgIndex } from '../h';\n\nexport type DirectiveIdentifier = symbol;\n\nexport type DirectiveCallbackResultKey = string;\n\nexport type TemplateDirective = ReturnType<typeof createDirective>;\n\nexport const directiveId = '9554857d-de86-490c-b840-97c0b09ec272';\n\nconst reservedKeys = new Set(['fragment']);\n\nconst registeredDirectiveKeys = new Set<DirectiveCallbackResultKey>();\n\nexport interface DirectiveInstance<\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_NODE extends Node = Element\n> {\n  node: DIRECTIVE_NODE;\n  pos: TemplateArgIndex;\n  args: DIRECTIVE_ARGS;\n}\n\nexport interface DirectiveDefinition<\n  DIRECTIVE_KEY extends DirectiveCallbackResultKey,\n  DIRECTIVE_ARGS extends unknown[],\n  DIRECTIVE_RESULT,\n  DIRECTIVE_NODE extends Node\n> {\n  type: 'attr' | 'node';\n  key?: DIRECTIVE_KEY;\n  callback: (\n    instances: DirectiveInstance<DIRECTIVE_ARGS, DIRECTIVE_NODE>[]\n  ) => DIRECTIVE_RESULT;\n}\n\n/**\n * Create a template directive.\n * @internal\n * @param definition Directive definition.\n */\nexport const createDirective = <\n  DIRECTIVE_KEY extends DirectiveCallbackResultKey = '',\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_RESULT = void,\n  DIRECTIVE_NODE extends Node = Element\n>(\n  definition: DirectiveDefinition<\n    DIRECTIVE_KEY,\n    DIRECTIVE_ARGS,\n    DIRECTIVE_RESULT,\n    DIRECTIVE_NODE\n  >\n) => {\n  const { key } = definition;\n  if (key) {\n    if (reservedKeys.has(key)) {\n      throw new Error(\n        `This key is reserved and cannot be used in a directive: \"${key}\"`\n      );\n    }\n    if (registeredDirectiveKeys.has(key)) {\n      throw new Error(`Directive key already in use: \"${key}\"`);\n    }\n    registeredDirectiveKeys.add(key);\n  }\n\n  const identifier = Symbol(definition.key || 'directive-definition');\n\n  return (...args: DIRECTIVE_ARGS) => ({\n    directive: directiveId,\n    identifier,\n    definition: {\n      ...definition,\n      key: definition.key || '',\n    },\n    args,\n  });\n};\n", "import {\n  DirectiveInstance,\n  createDirective,\n} from '../helpers/create-directive';\n\ntype ReferencedElementName = string;\n\ntype ReferencedElementCallback = (el: Element) => void;\n\n/**\n * If provided a\n * - string: will be used as a name to the referenced element.\n * - callback: the callback will received the referenced element as its first\n *             argument.\n */\ntype DirectiveArg = ReferencedElementName | ReferencedElementCallback;\n\n/**\n * Obtain a reference to an element.\n */\nexport const $ref = createDirective({\n  type: 'attr',\n  key: 'refs',\n  callback: (instances: DirectiveInstance<[DirectiveArg]>[]) => {\n    return instances.reduce((refs, { node, args: [keyOrCallback] }) => {\n      if (typeof keyOrCallback === 'function') {\n        keyOrCallback(node);\n      } else {\n        if (keyOrCallback in refs) {\n          throw new Error(`Duplicate $ref key: \"${keyOrCallback}\"`);\n        }\n        refs[keyOrCallback] = node;\n      }\n      return refs;\n    }, {} as Record<ReferencedElementName, Element>);\n  },\n});\n", "import type { ElementAttrs } from '../h';\n\n/**\n * Update attributes or properties on an element.\n * @internal\n * @param node Element whose attributes or properties need to be updated.\n * @param attrs Attributes or properties to update.\n */\nexport const updateElementAttrs = (\n  node: Element,\n  attrs: ElementAttrs\n): void => {\n  Object.entries(attrs).forEach(([attrName, attrValue]) => {\n    switch (attrName) {\n      case 'style':\n        Object.entries(attrValue as Required<ElementAttrs>['style']).forEach(\n          ([stylePropName, stylePropValue]) => {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            node.style[stylePropName] = stylePropValue;\n          }\n        );\n        break;\n      case 'dataset':\n        Object.entries(attrValue as Required<ElementAttrs>['dataset']).forEach(\n          ([dataPropName, dataPropValue]) => {\n            (node as HTMLElement).dataset[dataPropName] = dataPropValue;\n          }\n        );\n        break;\n      default: {\n        const isAttr =\n          (attrName.startsWith('[') || attrName.startsWith('![')) &&\n          attrName.endsWith(']');\n        if (isAttr) {\n          // \"![attribute-name]\" = attribute should be removed. This is useful\n          // when we need to remove \"boolean attributes\"\n          // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\n          if (attrName.startsWith('![')) {\n            node.removeAttribute(attrName.substring(2, attrName.length - 1));\n          } else {\n            node.setAttribute(\n              attrName.substring(1, attrName.length - 1),\n              String(attrValue)\n            );\n          }\n        } else {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const nodeProp = node[attrName] as unknown;\n\n          if (typeof nodeProp === 'function' && Array.isArray(attrValue)) {\n            nodeProp.apply(node, attrValue);\n          } else {\n            if (nodeProp !== attrValue) {\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              node[attrName] = attrValue;\n            }\n          }\n        }\n      }\n    }\n  });\n};\n", "import type { ElementAttrs } from '../h';\nimport {\n  DirectiveInstance,\n  createDirective,\n} from '../helpers/create-directive';\nimport { updateElementAttrs } from '../helpers/update-element-attrs';\n\n/**\n * A unique name of the element whose attributes or properties can be updated.\n */\ntype DirectiveArg = string;\n\n/**\n * Marks an element has having updatable attributes and properties.\n */\nexport const $updatable = createDirective({\n  type: 'attr',\n  key: 'update',\n  callback: (instances: DirectiveInstance<[DirectiveArg]>[]) => {\n    const nodeMap = instances.reduce((map, { node, args: [nodeKey] }) => {\n      if (map.has(nodeKey)) {\n        throw new Error(`Duplicate $updatable key: \"${nodeKey}\"`);\n      }\n      return map.set(nodeKey, node);\n    }, new Map<DirectiveArg, Element>());\n\n    return (args: { [nodeKey: DirectiveArg]: ElementAttrs }) => {\n      Object.entries(args).forEach(([nodeKey, nodeAttrs]) => {\n        const node = nodeMap.get(nodeKey);\n        if (node) {\n          updateElementAttrs(node, nodeAttrs);\n        }\n      });\n    };\n  },\n});\n", "/**\n * Replaces a node if `newContent` is not identical to `currentNode`.\n * @internal\n * @param currentNode Current node to update.\n * @param newContent New text content or a new node to replace `currentNode`\n *     with.\n */\nexport const updateNode = (\n  currentNode: Text | Element,\n  newContent: string | Node\n): Text | Element => {\n  let replacedNode: Node = currentNode;\n  const newNode =\n    typeof newContent === 'string' ? new Text(newContent) : newContent;\n  if (\n    !(\n      currentNode instanceof Text &&\n      newNode instanceof Text &&\n      currentNode.textContent === newNode.textContent\n    ) &&\n    currentNode !== newNode\n  ) {\n    currentNode.replaceWith(newNode as Node);\n    replacedNode = newNode;\n  }\n  return replacedNode as Text | Element;\n};\n", "import {\n  DirectiveInstance,\n  createDirective,\n} from '../helpers/create-directive';\nimport { updateNode } from '../helpers/update-node';\n\n/**\n * A unique key that identifies the updatable node.\n */\ntype DirectiveArg = string;\n\n/**\n * Marks a node as being updatable.\n */\nexport const $updatableNode = createDirective({\n  type: 'node',\n  key: 'updateNode',\n  callback: (\n    instances: DirectiveInstance<[DirectiveArg], Element | Text>[]\n  ) => {\n    const nodeMap = instances.reduce((map, { node, args: [nodeKey] }) => {\n      if (map.has(nodeKey)) {\n        throw new Error(`Duplicate $updatableNode key: \"${nodeKey}\"`);\n      }\n      return map.set(nodeKey, node);\n    }, new Map<DirectiveArg, Element | Text>());\n\n    return (args: { [nodeKey: DirectiveArg]: string | Node }) => {\n      Object.entries(args).forEach(([nodeKey, newContent]) => {\n        const node = nodeMap.get(nodeKey);\n        if (node) {\n          nodeMap.set(nodeKey, updateNode(node, newContent));\n        }\n      });\n    };\n  },\n});\n"],
  "mappings": "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",
  "names": ["directiveId", "reservedKeys", "registeredDirectiveKeys", "createDirective", "definition", "key", "identifier", "args", "__spreadProps", "__spreadValues", "$ref", "createDirective", "instances", "refs", "node", "keyOrCallback", "updateElementAttrs", "node", "attrs", "attrName", "attrValue", "stylePropName", "stylePropValue", "dataPropName", "dataPropValue", "nodeProp", "$updatable", "createDirective", "instances", "nodeMap", "map", "node", "nodeKey", "args", "nodeAttrs", "updateElementAttrs", "updateNode", "currentNode", "newContent", "replacedNode", "newNode", "$updatableNode", "createDirective", "instances", "nodeMap", "map", "node", "nodeKey", "args", "newContent", "updateNode"]
}
