{
  "version": 3,
  "sources": ["../src/helpers/is-plain-object.ts", "../src/helpers/create-directive.ts", "../src/helpers/is-directive.ts", "../src/helpers/update-element-attrs.ts", "../src/h.ts", "../src/repeat.ts", "../src/style.ts"],
  "sourcesContent": ["/**\n * This check is meant to guard against honest mistakes not scenarios where the\n * user is deliberately trying pass a value off as a plain object.\n * @internal\n */\nexport const isPlainObject = (arg: unknown): arg is object =>\n  Boolean(\n    arg && (arg.constructor === Object || Object.getPrototypeOf(arg) === null)\n  );\n", "import type { TemplateArgIndex } from '../h';\n\nexport type DirectiveIdentifier = symbol;\n\nexport type DirectiveCallbackResultKey = string;\n\nexport type TemplateDirective = ReturnType<typeof createDirective>;\n\nexport const directiveId = '9554857d-de86-490c-b840-97c0b09ec272';\n\nconst reservedKeys = new Set(['fragment']);\n\nconst registeredDirectiveKeys = new Set<DirectiveCallbackResultKey>();\n\nexport interface DirectiveInstance<\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_NODE extends Node = Element\n> {\n  node: DIRECTIVE_NODE;\n  pos: TemplateArgIndex;\n  args: DIRECTIVE_ARGS;\n}\n\nexport interface DirectiveDefinition<\n  DIRECTIVE_KEY extends DirectiveCallbackResultKey,\n  DIRECTIVE_ARGS extends unknown[],\n  DIRECTIVE_RESULT,\n  DIRECTIVE_NODE extends Node\n> {\n  type: 'attr' | 'node';\n  key?: DIRECTIVE_KEY;\n  callback: (\n    instances: DirectiveInstance<DIRECTIVE_ARGS, DIRECTIVE_NODE>[]\n  ) => DIRECTIVE_RESULT;\n}\n\n/**\n * Create a template directive.\n * @internal\n * @param definition Directive definition.\n */\nexport const createDirective = <\n  DIRECTIVE_KEY extends DirectiveCallbackResultKey = '',\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_RESULT = void,\n  DIRECTIVE_NODE extends Node = Element\n>(\n  definition: DirectiveDefinition<\n    DIRECTIVE_KEY,\n    DIRECTIVE_ARGS,\n    DIRECTIVE_RESULT,\n    DIRECTIVE_NODE\n  >\n) => {\n  const { key } = definition;\n  if (key) {\n    if (reservedKeys.has(key)) {\n      throw new Error(\n        `This key is reserved and cannot be used in a directive: \"${key}\"`\n      );\n    }\n    if (registeredDirectiveKeys.has(key)) {\n      throw new Error(`Directive key already in use: \"${key}\"`);\n    }\n    registeredDirectiveKeys.add(key);\n  }\n\n  const identifier = Symbol(definition.key || 'directive-definition');\n\n  return (...args: DIRECTIVE_ARGS) => ({\n    directive: directiveId,\n    identifier,\n    definition: {\n      ...definition,\n      key: definition.key || '',\n    },\n    args,\n  });\n};\n", "import { isPlainObject } from './is-plain-object';\nimport { directiveId, createDirective } from './create-directive';\n\n/**\n * Determines if the supplied `arg` is a valid TemplateDirective value.\n * @internal\n * @param arg Arg to check.\n */\nexport const isDirective = (\n  arg: unknown\n): arg is ReturnType<ReturnType<typeof createDirective>> => {\n  return (\n    isPlainObject(arg) && 'directive' in arg && arg['directive'] === directiveId\n  );\n};\n", "import type { ElementAttrs } from '../h';\n\n/**\n * Update attributes or properties on an element.\n * @internal\n * @param node Element whose attributes or properties need to be updated.\n * @param attrs Attributes or properties to update.\n */\nexport const updateElementAttrs = (\n  node: Element,\n  attrs: ElementAttrs\n): void => {\n  Object.entries(attrs).forEach(([attrName, attrValue]) => {\n    switch (attrName) {\n      case 'style':\n        Object.entries(attrValue as Required<ElementAttrs>['style']).forEach(\n          ([stylePropName, stylePropValue]) => {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            node.style[stylePropName] = stylePropValue;\n          }\n        );\n        break;\n      case 'dataset':\n        Object.entries(attrValue as Required<ElementAttrs>['dataset']).forEach(\n          ([dataPropName, dataPropValue]) => {\n            (node as HTMLElement).dataset[dataPropName] = dataPropValue;\n          }\n        );\n        break;\n      default: {\n        const isAttr =\n          (attrName.startsWith('[') || attrName.startsWith('![')) &&\n          attrName.endsWith(']');\n        if (isAttr) {\n          // \"![attribute-name]\" = attribute should be removed. This is useful\n          // when we need to remove \"boolean attributes\"\n          // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\n          if (attrName.startsWith('![')) {\n            node.removeAttribute(attrName.substring(2, attrName.length - 1));\n          } else {\n            node.setAttribute(\n              attrName.substring(1, attrName.length - 1),\n              String(attrValue)\n            );\n          }\n        } else {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const nodeProp = node[attrName] as unknown;\n\n          if (typeof nodeProp === 'function' && Array.isArray(attrValue)) {\n            nodeProp.apply(node, attrValue);\n          } else {\n            if (nodeProp !== attrValue) {\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              node[attrName] = attrValue;\n            }\n          }\n        }\n      }\n    }\n  });\n};\n", "import { isPlainObject } from './helpers/is-plain-object';\nimport { isDirective } from './helpers/is-directive';\nimport { updateElementAttrs } from './helpers/update-element-attrs';\nimport type {\n  DirectiveIdentifier,\n  DirectiveInstance,\n  DirectiveCallbackResultKey,\n  createDirective,\n  TemplateDirective,\n} from './helpers/create-directive';\n\nexport type ElementAttrs = {\n  /**\n   * CSS inline styles for the Element. The properties are expected to be in\n   * camelCase.\n   */\n  style?: Partial<CSSStyleDeclaration>;\n  /**\n   * A DOM string map of custom data attribute properties set on the element.\n   * The properties are expected to be in camelCase.\n   */\n  dataset?: HTMLOrSVGElement['dataset'];\n  /**\n   * Other miscellaneous attributes or properties that will be assigned to the\n   * Element.\n   */\n  [attr: string]: unknown;\n} & Partial<GlobalEventHandlers> &\n  Partial<ARIAMixin> &\n  Partial<InnerHTML> &\n  Partial<Node> &\n  Partial<Element>;\n\nexport type TemplateArgIndex = number;\n\ntype TaggedAttrArg = string;\n\ntype TaggedArgsMap = Map<\n  TemplateArgIndex,\n  Node | ElementAttrs | TemplateDirective\n>;\n\n// todo: make $repeat?\n\n/**\n * Tags a template attributes argument in the template.\n * @internal\n * @param i Template literal argument index.\n */\nconst tagAttrsArg = (i: TemplateArgIndex): TaggedAttrArg =>\n  `data-FHF7Sj5kD1S-${i}`;\n\n/**\n * Tags a template node argument in the template.\n * @internal\n * @param i Template literal argument index.\n */\nconst tagNodeArg = (i: TemplateArgIndex): string =>\n  `<template ${tagAttrsArg(i)}></template>`;\n\n/**\n * Parses an HTML template.\n * @internal\n * @param htmlStrings Template literal HTML strings.\n * @param templateArgs Template literal interpolated directiveValues.\n */\nconst parse = (\n  htmlStrings: TemplateStringsArray,\n  templateArgs: (\n    | string\n    | number\n    | boolean\n    | Node\n    | ElementAttrs\n    | TemplateDirective\n  )[]\n): {\n  taggedTemplate: HTMLTemplateElement;\n  taggedArgs: TaggedArgsMap;\n} => {\n  const taggedArgs: TaggedArgsMap = new Map();\n\n  // Intentionally using a `template` instead of something like a `div` as we\n  // do not want any events from the elements to trigger while we're parsing the\n  // template.\n  const taggedTemplate = document.createElement('template');\n\n  const lastHtmlStringIndex = htmlStrings.length - 1;\n\n  taggedTemplate.innerHTML = htmlStrings\n    .reduce((combinedHtmlStrings, htmlString, argIndex) => {\n      const htmlChunk = `${combinedHtmlStrings}${htmlString}`;\n      const arg = templateArgs[argIndex];\n      const argType = typeof arg;\n      if (argIndex === lastHtmlStringIndex) {\n        return htmlChunk;\n      } else if (\n        argType === 'string' ||\n        argType === 'number' ||\n        argType === 'boolean'\n      ) {\n        return `${htmlChunk}${arg}`;\n      } else if (arg instanceof Node) {\n        taggedArgs.set(argIndex, arg as Node);\n        return `${htmlChunk}${tagNodeArg(argIndex)}`;\n      } else if (isDirective(arg)) {\n        taggedArgs.set(argIndex, arg);\n        return `${htmlChunk}${\n          arg.definition.type === 'attr'\n            ? tagAttrsArg(argIndex)\n            : tagNodeArg(argIndex)\n        }`;\n      } else if (isPlainObject(arg)) {\n        taggedArgs.set(argIndex, arg);\n        return `${htmlChunk}${tagAttrsArg(argIndex)}`;\n      } else {\n        throw new Error(\n          `Invalid template argument at position ${argIndex} ` +\n            `(zero-based numbering)`\n        );\n      }\n    }, '')\n    // The combined HTML strings must be trimmed to remove meaningless\n    // whitespace characters. If not, given a string like this:\n    // h`\n    //   <p>Hello</p>\n    // `\n    // \"container.childNodes.length\" > 1 even though the only relevant node in\n    // that string is the \"p\" element.\n    .trim();\n\n  return {\n    taggedTemplate,\n    taggedArgs,\n  };\n};\n\n/**\n * Interpolate parsed HTML template literal with template literal arguments.\n * @internal\n * @param args Parsed and tagged HTML attributes or nodes.\n */\nconst interpolate = ({\n  taggedTemplate,\n  taggedArgs,\n}: ReturnType<typeof parse>): {\n  content: Node | DocumentFragment;\n  [directiveKey: DirectiveCallbackResultKey]: unknown;\n} => {\n  const fragment = taggedTemplate.content.cloneNode(true) as DocumentFragment;\n  const directives = new Map<\n    DirectiveIdentifier,\n    {\n      callback: Parameters<typeof createDirective>[0]['callback'];\n      key: Parameters<typeof createDirective>[0]['key'];\n      instances: DirectiveInstance[];\n    }\n  >();\n\n  taggedArgs.forEach((arg, argIndex) => {\n    const taggedAttr = tagAttrsArg(argIndex);\n\n    const node = fragment.querySelector(`[${taggedAttr}]`);\n    if (!node) {\n      throw new Error(\n        `Unexpected template argument at position ${argIndex} ` +\n          `(zero-based numbering)`\n      );\n    }\n\n    node.removeAttribute(taggedAttr);\n\n    if (arg instanceof Node) {\n      node.replaceWith(arg);\n    } else if (isDirective(arg)) {\n      const { identifier, args } = arg;\n      const { callback, key } = arg.definition;\n      const instances = directives.get(identifier)?.instances || [];\n      instances.push({ node, pos: argIndex, args });\n      directives.set(identifier, { callback, key, instances });\n    } else {\n      updateElementAttrs(node, arg as ElementAttrs);\n    }\n  });\n\n  const results: { content: Node } & Record<string, unknown> = {\n    content:\n      fragment.childNodes.length === 1\n        ? (fragment.childNodes[0] as Node)\n        : fragment,\n  };\n\n  directives.forEach(({ key, callback, instances }) => {\n    const callbackResults = callback(instances);\n    if (key) {\n      results[key] = callbackResults;\n    }\n  });\n\n  return results;\n};\n\nexport const h = (\n  htmlStrings: TemplateStringsArray,\n  ...templateArgs: (\n    | string\n    | number\n    | boolean\n    | Node\n    | ElementAttrs\n    | TemplateDirective\n  )[]\n): ReturnType<typeof interpolate> => {\n  return interpolate(parse(htmlStrings, templateArgs));\n};\n", "interface HRepeatElementCallbackParams<ITEM> {\n  key: unknown;\n  item: ITEM;\n  index: number;\n}\n\ninterface HRepeatRefCallbackParams<ITEM, ELEMENT extends Element>\n  extends HRepeatElementCallbackParams<ITEM> {\n  element: ELEMENT;\n}\n\ninterface HRepeatKeyCallback<ITEM> {\n  ({ key, item, index }: HRepeatElementCallbackParams<ITEM>): string;\n}\n\ninterface HRepeatElementCallback<ITEM, ELEMENT extends Element> {\n  ({ key, item, index }: HRepeatElementCallbackParams<ITEM>): ELEMENT;\n}\n\ninterface HRepeatRefCallback<ITEM, ELEMENT extends Element> {\n  ({ key, item, index }: HRepeatRefCallbackParams<ITEM, ELEMENT>): void;\n}\n\ninterface HRepeatParams<ITEM, ELEMENT extends Element> {\n  container: HTMLElement;\n  items:\n    | Map<unknown, ITEM>\n    | Set<ITEM>\n    | ITEM[]\n    | Record<string | number | symbol, ITEM>;\n  element: HRepeatElementCallback<ITEM, ELEMENT>;\n  ref?: HRepeatRefCallback<ITEM, ELEMENT>;\n  key?: HRepeatKeyCallback<ITEM>;\n  keyName?: string;\n}\n\n/**\n * Render a collection of Elements.\n */\nexport const repeat = <ITEM, ELEMENT extends Element>({\n  container,\n  items,\n  element: elementCallback,\n  ref,\n  key: keyValueCallback = (args) => String(args.key),\n  keyName = 'data-h-repeat-key',\n}: HRepeatParams<ITEM, ELEMENT>): void => {\n  const entries = Array.isArray(items)\n    ? items.entries()\n    : items instanceof Map\n    ? items\n    : items instanceof Set\n    ? Array.from(items).entries()\n    : Object.entries(items);\n\n  const savedKeys = new Set<string>();\n\n  let index = 0;\n  for (const [key, item] of entries) {\n    const keyValue = String(keyValueCallback({ key, item, index }));\n    savedKeys.add(keyValue);\n\n    let element = container.querySelector<ELEMENT>(\n      `:scope > [${keyName}=\"${keyValue}\"]`\n    );\n\n    if (!element) {\n      element = elementCallback({ key, item, index });\n      element.setAttribute(keyName, keyValue);\n      container.append(element);\n    }\n\n    if (ref && element) {\n      ref({ key, item, index, element });\n    }\n\n    index++;\n  }\n\n  container.querySelectorAll(`:scope > [${keyName}]`).forEach((element) => {\n    if (!savedKeys.has(element.getAttribute(keyName) as string)) {\n      element.remove();\n    }\n  });\n};\n", "type StyleRules = {\n  [selector: string]: Partial<CSSStyleDeclaration> | StyleRules;\n};\n\n/**\n * Create CSS styles given a plain JavaScript object.\n * @param rules CSS rules.\n */\nexport const style = (rules: StyleRules): string => {\n  return Object.entries(rules)\n    .map(([selector, styles]) => {\n      const cssText = Object.entries(styles).reduce((items, [name, value]) => {\n        if (typeof value === 'string') {\n          const snakeCasedName = name.replace(\n            /[A-Z]/g,\n            (c) => `-${c.toLowerCase()}`\n          );\n          return (items += `${snakeCasedName}:${value};`);\n        }\n        return style(styles as StyleRules);\n      }, '') as string;\n      return `${selector}{${cssText}}`;\n    })\n    .join('');\n};\n"],
  "mappings": "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",
  "names": ["isPlainObject", "arg", "directiveId", "isDirective", "arg", "isPlainObject", "directiveId", "updateElementAttrs", "node", "attrs", "attrName", "attrValue", "stylePropName", "stylePropValue", "dataPropName", "dataPropValue", "nodeProp", "tagAttrsArg", "i", "tagNodeArg", "parse", "htmlStrings", "templateArgs", "taggedArgs", "taggedTemplate", "lastHtmlStringIndex", "combinedHtmlStrings", "htmlString", "argIndex", "htmlChunk", "arg", "argType", "isDirective", "isPlainObject", "interpolate", "fragment", "directives", "_a", "taggedAttr", "node", "identifier", "args", "callback", "key", "instances", "updateElementAttrs", "results", "callbackResults", "h", "repeat", "container", "items", "elementCallback", "ref", "keyValueCallback", "args", "keyName", "entries", "savedKeys", "index", "key", "item", "keyValue", "element", "style", "rules", "selector", "styles", "cssText", "items", "name", "value", "snakeCasedName", "c"]
}
