{
  "version": 3,
  "sources": ["../src/helpers/attrs.ts", "../src/helpers/create-ref.ts", "../src/helpers/is-plain-object.ts", "../src/helpers/create-directive.ts", "../src/helpers/is-directive.ts", "../src/helpers/is-parsed-template.ts", "../src/h.ts", "../src/style.ts"],
  "sourcesContent": ["import type { TemplateAttrsExp } from '../h';\n\n/**\n * Update attributes or properties on an element.\n * @param node Element whose attributes or properties need to be updated.\n * @param nodeAttrs Attributes and/or properties to update.\n *     The behaviour of the following properties have been altered to\n *     simplify the process of updating these values:\n *     - \"className\": A space separated list of CSS classnames that will be\n *                    appended to an element's class list.\n *     - \"style\"    : CSS inline styles that will be applied to the element.\n *                    Style names are expected to be camelCased.\n *     - \"dataset\"  : DOM string map of custom data attributes. The attributes\n *                    are expected to be camelCased.\n *\n */\nexport const attrs = (node: HTMLElement, nodeAttrs: TemplateAttrsExp): void => {\n  Object.entries(nodeAttrs).forEach(([name, value]) => {\n    switch (name) {\n      case 'className': {\n        (value as string).split(/\\s{1,}/).forEach((name) => {\n          const trimmedName = name.trim();\n          if (trimmedName) {\n            node.classList.add(trimmedName);\n          }\n        });\n        break;\n      }\n      case 'style':\n        Object.assign(node.style, value);\n        break;\n      case 'dataset':\n        Object.assign(node.dataset, value);\n        break;\n      default: {\n        const isAttr = name.startsWith('[') && name.endsWith(']');\n        if (isAttr) {\n          const attrName = name.substring(1, name.length - 1);\n          if (value === false) {\n            node.removeAttribute(attrName);\n          } else {\n            node.setAttribute(\n              attrName,\n              value === true ? '' : (value as string),\n            );\n          }\n        } else {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const currentPropValue = node[name] as unknown;\n\n          if (currentPropValue !== value) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            node[name] = value;\n          }\n        }\n      }\n    }\n  });\n};\n", "import type { TemplateAttrsExp } from '../h';\nimport { attrs } from './attrs';\n\n/**\n * A CSS class name.\n * @internal\n */\ntype ClassName = string;\n\n/**\n * An HTML element attribute name.\n *\n * Attribute names are expected to be in \"snake-case\".\n *\n * @internal\n */\ntype AttrNameSnakeCased = string;\n\n/**\n * An HTML element custom data attribute name.\n *\n * Custom data attribute names are expected to be in \"cameCase\".\n *\n * @internal\n */\ntype DataAttrNameCamelCased = string;\n\n/**\n * Wraps a node with a utility functions to simplify making changes to the\n * node.\n * @param node Node to wrap\n */\nexport const createRef = <NODE extends HTMLElement>(node: NODE) => {\n  const nodePlaceholder = new Text('');\n  let removed = false;\n\n  const replaceNode = () => {\n    if (removed) {\n      nodePlaceholder.replaceWith(node);\n      removed = false;\n    }\n  };\n\n  return {\n    /**\n     * Provided node.\n     */\n    node,\n    /**\n     *\n     * @param cssClassNames CSS class names to add or remove\n     */\n    classMap: (cssClassNames: Record<ClassName, boolean>) => {\n      Object.entries(cssClassNames).forEach(([className, active]) => {\n        if (active) {\n          node.classList.add(className);\n        } else {\n          node.classList.remove(className);\n        }\n      });\n    },\n    attrMap: (attrs: Record<AttrNameSnakeCased, string | boolean>) => {\n      Object.entries(attrs).forEach(([attrName, value]) => {\n        if (value === false) {\n          node.removeAttribute(attrName);\n        } else {\n          node.setAttribute(attrName, value === true ? '' : value);\n        }\n      });\n    },\n    dataMap: (dataset: Record<DataAttrNameCamelCased, boolean | string>) => {\n      Object.entries(dataset).forEach(([dataAttrName, value]) => {\n        if (value === false) {\n          delete node.dataset[dataAttrName];\n        } else {\n          node.dataset[dataAttrName] = value === true ? '' : value;\n        }\n      });\n    },\n    text: (textContent: string) => {\n      if (node.textContent !== textContent) {\n        node.textContent = textContent;\n      }\n    },\n    style: (style: Partial<CSSStyleDeclaration>) => attrs(node, { style }),\n    attrs: (elementAttrs: TemplateAttrsExp) => attrs(node, elementAttrs),\n    show: () => {\n      node.style.removeProperty('display');\n      replaceNode();\n    },\n    hide: () => {\n      node.style.setProperty('display', 'none');\n      replaceNode();\n    },\n    remove: () => {\n      if (!removed) {\n        node.replaceWith(nodePlaceholder);\n        removed = true;\n      }\n    },\n  };\n};\n", "/**\n * Is `arg` a plain object?\n *\n * This check is meant to guard against honest mistakes not scenarios where the\n * user is deliberately trying pass a value off as a plain object.\n * @internal\n * @param arg Argument to check.\n */\nexport const isPlainObject = (arg: unknown): arg is object =>\n  Boolean(\n    arg && (arg.constructor === Object || Object.getPrototypeOf(arg) === null),\n  );\n", "import type { ParsedTemplate, TemplateExpIndex } from '../h';\n\n/**\n * Return values of template directives.\n * @internal\n */\nexport type TemplateDirectiveResults<K = unknown, V = unknown> = Record<\n  keyof K,\n  V\n>;\n\n/**\n * An instance of a directive template expression.\n * @internal\n */\nexport interface DirectiveInstance<\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_NODE extends HTMLElement = HTMLElement,\n> {\n  /**\n   * Node that the directive is attached to.\n   *\n   * Note: If this is a \"node\" type directive, it will be attached to a\n   * \"template\" element that serves as a placeholder.\n   */\n  node: DIRECTIVE_NODE;\n  /**\n   * Index position of the directive instance.\n   */\n  index: TemplateExpIndex;\n  /**\n   * Arguments provided to the directive.\n   */\n  args: DIRECTIVE_ARGS;\n}\n\n/**\n * Directive definition.\n * @internal\n */\nexport interface DirectiveDefinition<\n  DIRECTIVE_ARGS extends unknown[],\n  DIRECTIVE_NODE extends HTMLElement = HTMLElement,\n> {\n  /**\n   * Directive type:\n   * \"attr\" - Directive must be attached to an element and it modifies the\n   *          element it is attached to.\n   * \"node\" - Directive produces a node or template.\n   */\n  type: 'attr' | 'node';\n  /**\n   * Directive's callback that processes the provided arguments.\n   * @param template Template that the directive belongs to.\n   * @param instances All instances of the same directive.\n   */\n  callback: (\n    template: ParsedTemplate<unknown>,\n    instances: DirectiveInstance<DIRECTIVE_ARGS, DIRECTIVE_NODE>[],\n  ) => void;\n}\n\n/**\n * Property that identifies an object as an instance of a template directive\n * expression.\n * @internal\n */\nexport const directiveId = '__cI4Mp6yr0__';\n\n/**\n * Create a template directive.\n * @internal\n * @param definition Template directive definition.\n */\nexport const createDirective = <\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_NODE extends HTMLElement = HTMLElement,\n>(\n  def: DirectiveDefinition<DIRECTIVE_ARGS, DIRECTIVE_NODE>,\n) => {\n  return (...args: DIRECTIVE_ARGS) => ({\n    id: directiveId,\n    def,\n    args,\n  });\n};\n", "import type { TemplateDirectiveExp } from '../h';\nimport { isPlainObject } from './is-plain-object';\nimport { directiveId } from './create-directive';\n\n/**\n * Is `exp` a template directive?\n * @internal\n * @param exp Expression to check.\n */\nexport const isDirective = (exp: unknown): exp is TemplateDirectiveExp => {\n  return isPlainObject(exp) && 'id' in exp && exp['id'] === directiveId;\n};\n", "import { type ParsedTemplate, parsedTemplateId } from '../h';\nimport { isPlainObject } from './is-plain-object';\n\n/**\n * Is `arg` a parsed template?\n * @internal\n * @param arg Argument to check.\n */\nexport const isParsedTemplate = (arg: unknown): arg is ParsedTemplate => {\n  return isPlainObject(arg) && '$id' in arg && arg['$id'] === parsedTemplateId;\n};\n", "import type {\n  DirectiveDefinition,\n  DirectiveInstance,\n  TemplateDirectiveResults,\n  createDirective,\n} from './helpers/create-directive';\nimport { attrs } from './helpers/attrs';\nimport { createRef } from './helpers/create-ref';\nimport { isPlainObject } from './helpers/is-plain-object';\nimport { isDirective } from './helpers/is-directive';\nimport { isParsedTemplate } from './helpers/is-parsed-template';\n\n/**\n * A template that has been parsed by h.\n */\nexport type ParsedTemplate<\n  NODE_TYPE = HTMLElement,\n  DIRECTIVES extends TemplateDirectiveResults = TemplateDirectiveResults,\n> = {\n  $id: typeof parsedTemplateId;\n  $cb: TemplateCallbackSet;\n  $node: NODE_TYPE;\n} & DIRECTIVES;\n\n/**\n * An \"attributes\" template expression.\n */\nexport type TemplateAttrsExp<\n  CUSTOM_ATTRS extends { [P in keyof CUSTOM_ATTRS]: CUSTOM_ATTRS[P] } = object,\n> = {\n  /**\n   * CSS classes that will be appended to the element.\n   */\n  className?: string;\n  /**\n   * CSS inline styles for the element. The properties are expected to be in\n   * camelCase.\n   */\n  style?: Partial<CSSStyleDeclaration>;\n  /**\n   * A DOM string map of custom data attribute properties set on the element.\n   * The properties are expected to be in camelCase.\n   */\n  dataset?: HTMLOrSVGElement['dataset'];\n  /**\n   * Other attributes or properties that will be assigned to the element.\n   */\n  [attr: string]: unknown;\n} & Partial<GlobalEventHandlers> &\n  Partial<ARIAMixin> &\n  Partial<InnerHTML> &\n  Partial<Node> &\n  Partial<Element> &\n  CUSTOM_ATTRS;\n\n/**\n * A \"directive\" template expression.\n */\nexport type TemplateDirectiveExp = ReturnType<\n  ReturnType<typeof createDirective>\n>;\n\nexport type TemplateCallbackRef<\n  NODE_TYPE extends HTMLElement = HTMLElement,\n  PARSED_TEMPLATE extends ParsedTemplate = ParsedTemplate,\n> = ElementRef<NODE_TYPE> & { tpl: PARSED_TEMPLATE };\n\n/**\n * A \"callback\" template expression.\n *\n * Notes:\n * - All callbacks expressions are collected into a set call \"$cb\" that is\n *   attached to a parsed template.\n * - This callback is not executed until $cb.run() is called. This allows you\n *   to control when callbacks which allows for the creation of more complex\n *   closures.\n * - If the callback returns false, it will be removed from \"$cb\" the first\n *   time it is executed (i.e. one-off callbacks expressions).\n */\nexport type TemplateCallbackExp<\n  NODE_TYPE extends HTMLElement = HTMLElement,\n  PARSED_TEMPLATE extends ParsedTemplate = ParsedTemplate,\n> = (ref: TemplateCallbackRef<NODE_TYPE, PARSED_TEMPLATE>) => unknown;\n\n/**\n * Valid template expressions.\n * @internal\n */\ntype TemplateExps =\n  | string\n  | number\n  | boolean\n  | Node\n  | TemplateAttrsExp\n  | TemplateCallbackExp\n  | TemplateDirectiveExp\n  | ParsedTemplate\n  | (\n      | string\n      | number\n      | boolean\n      | Node\n      | TemplateAttrsExp\n      | TemplateCallbackExp\n      | TemplateDirectiveExp\n      | ParsedTemplate\n    )[];\n\n/**\n * An \"attribute\" template expression that has been tagged and is ready for\n * interpolation.\n * @internal\n */\ntype TaggedTemplateAttrsExp = string;\n\n/**\n * A \"node\" template expression that has been tagged and is ready for\n * interpolation.\n * @internal\n */\ntype TaggedNodeExp = string;\n\n/**\n * The index position of a template expression.\n * @internal\n */\nexport type TemplateExpIndex = number;\n\n/**\n * A map of template expression index position to template expression.\n * @internal\n */\ntype TaggedExpMap = Map<\n  TemplateExpIndex,\n  Node | TemplateCallbackExp | TemplateAttrsExp | TemplateDirectiveExp\n>;\n\n/**\n * A wrapper around an HTML element that provides additional utility functions.\n */\nexport type ElementRef<NODE extends HTMLElement = HTMLElement> = ReturnType<\n  typeof createRef<NODE>\n>;\n\n/**\n * An internal property to identify parsed template objects.\n * @internal\n */\nexport const parsedTemplateId = '__PzroJBb1g__';\n\n/**\n * Tags an \"attributes\" template expression for interpolation.\n *\n * @internal\n * @param i Template expression index position.\n */\nconst tagAttrsExp = (i: TemplateExpIndex): TaggedTemplateAttrsExp =>\n  `data-FHF7Sj5kD1S-${i}`;\n\n/**\n * Tags a \"node\" template expression for interpolation.\n * @internal\n * @param i Template expression index position.\n */\nconst tagNodeExp = (i: TemplateExpIndex): TaggedNodeExp =>\n  `<template ${tagAttrsExp(i)}></template>`;\n\n/**\n * Set of all callback expressions in a parsed template.\n * @internal\n */\nclass TemplateCallbackSet extends Set<() => unknown> {\n  /**\n   * Execute all callbacks.\n   */\n  run() {\n    this.forEach((callback) => {\n      if (callback() === false) {\n        this.delete(callback);\n      }\n    });\n  }\n\n  /**\n   * Execute all callbacks inside \"requestAnimationFrame\"\n   */\n  runAsync() {\n    window.requestAnimationFrame(() => this.run());\n  }\n}\n\n/**\n * Tags all expressions in a template.\n * @internal\n * @param htmlStrings Template literal HTML strings.\n * @param templateExps Template literal expressions.\n */\nconst tag = (\n  htmlStrings: TemplateStringsArray,\n  templateExps: TemplateExps[],\n): {\n  taggedTemplate: HTMLTemplateElement;\n  taggedExps: TaggedExpMap;\n  createErrorTemplate: () => string;\n} => {\n  const taggedExps: TaggedExpMap = new Map();\n\n  // Intentionally using a `template` instead of something like a `div` as we\n  // do not want any events from the elements to trigger while we're parsing the\n  // template.\n  const taggedTemplate = document.createElement('template');\n\n  const createErrorTemplate = () => {\n    let expIndex = 0;\n    return htmlStrings.reduce((chunks, chunk, templateExpsIndex) => {\n      if (templateExpsIndex === 0) {\n        return chunk;\n      }\n      const currentExp = templateExps[templateExpsIndex - 1];\n      let exp = '';\n      if (Array.isArray(currentExp)) {\n        exp = `\\${[${currentExp.map((_, i) => i).join(',')}]}`;\n        expIndex += currentExp.length;\n      } else {\n        exp = `\\${${expIndex}}`;\n        expIndex++;\n      }\n      return `${chunks}${exp}${chunk}`;\n    }, '');\n  };\n\n  let expCount = -1;\n  taggedTemplate.innerHTML = htmlStrings\n    .reduce((combinedHtmlStrings, htmlString, expIndex) => {\n      let htmlChunk = `${combinedHtmlStrings}${htmlString}`;\n\n      if (!(expIndex in templateExps)) return htmlChunk;\n\n      const currentExp = templateExps[expIndex] as TemplateExps;\n\n      ([] as TemplateExps[]).concat(currentExp).forEach((exp) => {\n        expCount++;\n\n        // TODO: should we escape expression automatically?\n\n        const expType = typeof exp;\n        if (\n          expType === 'string' ||\n          expType === 'number' ||\n          expType === 'boolean'\n        ) {\n          htmlChunk += exp;\n        } else if (expType === 'function') {\n          taggedExps.set(expCount, exp as TemplateCallbackExp);\n          htmlChunk += tagAttrsExp(expCount);\n        } else if (exp instanceof Node) {\n          taggedExps.set(expCount, exp as Node);\n          htmlChunk += tagNodeExp(expCount);\n        } else if (isParsedTemplate(exp)) {\n          taggedExps.set(expCount, exp.$node);\n          htmlChunk += tagNodeExp(expCount);\n        } else if (isDirective(exp)) {\n          taggedExps.set(expCount, exp);\n          htmlChunk +=\n            exp.def.type === 'attr'\n              ? tagAttrsExp(expCount)\n              : tagNodeExp(expCount);\n        } else if (isPlainObject(exp)) {\n          taggedExps.set(expCount, exp as TemplateAttrsExp);\n          htmlChunk += tagAttrsExp(expCount);\n        } else {\n          throw new Error(\n            `Invalid template expression at index ${expCount}:\\n` +\n              createErrorTemplate(),\n          );\n        }\n      });\n      return htmlChunk;\n    }, '')\n    // The combined HTML strings must be trimmed to remove meaningless\n    // whitespace characters. If not, given a string like this:\n    // h`\n    //   <p>Hello</p>\n    // `\n    // \"container.childNodes.length\" > 1 even though the only relevant node in\n    // that string is the \"p\" element.\n    .trim();\n\n  return { taggedTemplate, taggedExps, createErrorTemplate };\n};\n\n/**\n * Interpolate a tagged template with the provided template expressions.\n * @internal\n * @param template Tagged template\n */\nconst interpolate = <\n  NODE_TYPE = HTMLElement,\n  DIRECTIVES extends TemplateDirectiveResults = TemplateDirectiveResults,\n>({\n  taggedTemplate,\n  taggedExps,\n  createErrorTemplate,\n}: ReturnType<typeof tag>): ParsedTemplate<NODE_TYPE, DIRECTIVES> => {\n  type Template = ParsedTemplate<NODE_TYPE, DIRECTIVES>;\n\n  const fragment = taggedTemplate.content.cloneNode(true) as DocumentFragment;\n  const directives = new Map<\n    DirectiveDefinition<unknown[], HTMLElement>,\n    DirectiveInstance[]\n  >();\n\n  const refs: TemplateCallbackRef[] = [];\n  const callbackExps = new TemplateCallbackSet();\n  taggedExps.forEach((exp, expIndex) => {\n    const taggedAttr = tagAttrsExp(expIndex);\n\n    const node = fragment.querySelector<HTMLElement>(`[${taggedAttr}]`);\n    if (!node) {\n      const template = document.createElement('template');\n      template.append(fragment);\n      console.error(template);\n      throw new Error(\n        `Unable to interpolate expression at index ${expIndex}. ` +\n          `This could also have occurred because some prior expression was ` +\n          `mismatched.\\n${createErrorTemplate()}`,\n      );\n    }\n\n    node.removeAttribute(taggedAttr);\n\n    if (exp instanceof Node) {\n      node.replaceWith(exp);\n    } else if (isDirective(exp)) {\n      const { def, args } = exp;\n      const instances = directives.get(def) || [];\n      instances.push({ node, index: expIndex, args });\n      directives.set(def, instances);\n    } else if (typeof exp === 'function') {\n      const ref = createRef(node) as TemplateCallbackRef;\n      refs.push(ref);\n      callbackExps.add(() => exp(ref));\n    } else {\n      attrs(node, exp as TemplateAttrsExp);\n    }\n  });\n\n  const template = new Proxy<Template>(\n    Object.defineProperties({} as Template, {\n      $id: {\n        value: parsedTemplateId,\n        enumerable: false,\n      },\n      $cb: {\n        value: callbackExps,\n        enumerable: false,\n      },\n      $node: {\n        value:\n          fragment.childNodes.length === 1 ? fragment.childNodes[0] : fragment,\n        enumerable: false,\n      },\n    }),\n    {\n      defineProperty(target, key, descriptor) {\n        if (typeof key === 'string' && key.startsWith('$')) {\n          throw new Error(\n            'The \"$\" prefix is reserved and cannot be used to declare ' +\n              `additional properties on a parsed template: \"${key}\"`,\n          );\n        }\n        if (key in target) {\n          throw new Error(`Duplicate parsed template key: \"${String(key)}\"`);\n        }\n        Object.defineProperty(target, key, descriptor);\n        return true;\n      },\n    },\n  );\n\n  // Attach parsed template to all callback refs.\n  refs.forEach((ref) => Object.defineProperty(ref, 'tpl', { value: template }));\n\n  directives.forEach((instances, { callback }) => {\n    callback(template, instances);\n  });\n\n  return template;\n};\n\n/**\n * Parse an HTML template\n * @param htmlStrings HTML strings.\n * @param templateExps Template expressions\n * @returns A parsed HTML template.\n */\nexport const h = <\n  NODE_TYPE = HTMLElement,\n  DIRECTIVES extends TemplateDirectiveResults = TemplateDirectiveResults,\n>(\n  htmlStrings: TemplateStringsArray,\n  ...templateExps: TemplateExps[]\n): ReturnType<typeof interpolate<NODE_TYPE, DIRECTIVES>> => {\n  return interpolate(tag(htmlStrings, templateExps));\n};\n", "type StyleRules = {\n  [selector: string]: Partial<CSSStyleDeclaration> | StyleRules;\n};\n\n/**\n * Create CSS styles from plain JavaScript objects.\n * @param rules CSS rules.\n */\nexport const style = (rules: StyleRules): string => {\n  return Object.entries(rules)\n    .map(([selector, styles]) => {\n      const cssText = Object.entries(styles).reduce((items, [name, value]) => {\n        if (typeof value === 'string') {\n          const snakeCasedName = name.replace(\n            /[A-Z]/g,\n            (c) => `-${c.toLowerCase()}`,\n          );\n          return (items += `${snakeCasedName}:${value};`);\n        }\n        return style(styles as StyleRules);\n      }, '') as string;\n      return `${selector}{${cssText}}`;\n    })\n    .join('');\n};\n"],
  "mappings": "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",
  "names": ["attrs", "node", "nodeAttrs", "name", "value", "trimmedName", "attrName", "createRef", "node", "nodePlaceholder", "removed", "replaceNode", "cssClassNames", "className", "active", "attrs", "attrName", "value", "dataset", "dataAttrName", "textContent", "style", "elementAttrs", "isPlainObject", "arg", "directiveId", "isDirective", "exp", "isPlainObject", "directiveId", "isParsedTemplate", "arg", "isPlainObject", "parsedTemplateId", "parsedTemplateId", "tagAttrsExp", "i", "tagNodeExp", "TemplateCallbackSet", "callback", "tag", "htmlStrings", "templateExps", "taggedExps", "taggedTemplate", "createErrorTemplate", "expIndex", "chunks", "chunk", "templateExpsIndex", "currentExp", "exp", "_", "expCount", "combinedHtmlStrings", "htmlString", "htmlChunk", "expType", "isParsedTemplate", "isDirective", "isPlainObject", "interpolate", "fragment", "directives", "refs", "callbackExps", "taggedAttr", "node", "template", "def", "args", "instances", "ref", "createRef", "attrs", "target", "key", "descriptor", "style", "rules", "selector", "styles", "cssText", "items", "name", "value", "snakeCasedName", "c"]
}
