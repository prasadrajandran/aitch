{
  "version": 3,
  "sources": ["../src/h.ts"],
  "sourcesContent": ["type ElementAttrs = {\n  /**\n   * Obtain a reference to the instantiated Element with this callback.\n   * @param element\n   */\n  $ref?: (element: Element) => void;\n  /**\n   * CSS inline styles for the Element. The properties are expected to be in\n   * camelCase.\n   */\n  style?: Partial<CSSStyleDeclaration>;\n  /**\n   * A DOM string map of data attribute properties that will be attached to the\n   * element. The properties are expected to be in camelCase.\n   */\n  dataset?: HTMLOrSVGElement['dataset'];\n  /**\n   * Other miscellaneous attributes or properties that will be assigned to the\n   * Element.\n   */\n  [attr: string]: unknown;\n} & Partial<GlobalEventHandlers>;\n\ntype TemplateLiteralArgIndex = number;\n\ntype TaggedArgsMap = Map<TemplateLiteralArgIndex, Node | ElementAttrs>;\n\n/**\n * Template literal attribute/node argument attribute marker.\n */\nconst TAGGED_ATTR_NAME = 'data-FHF7Sj5kD1S';\n\n/**\n * Make a template literal attribute argument marker.\n * @param i Template literal argument index.\n */\nconst makeTaggedAttr = (i: number): string => `${TAGGED_ATTR_NAME}=\"${i}\"`;\n\n/**\n * Make a template literal node argument marker.\n * @param i Template literal argument index.\n */\nconst makeTaggedNode = (i: number): string => `<i ${makeTaggedAttr(i)}></i>`;\n\n/**\n * Parses HTML template literal and tags interpolated attributes and nodes.\n * @param htmlStrings Template literal HTML strings.\n * @param templateArgs Template literal interpolated values.\n */\nconst parseAndTagArgs = (\n  htmlStrings: TemplateStringsArray,\n  templateArgs: (string | number | boolean | ElementAttrs | Node)[]\n): {\n  template: HTMLTemplateElement;\n  taggedArgs: TaggedArgsMap;\n} => {\n  const taggedArgs: TaggedArgsMap = new Map();\n\n  // Intentionally using a `template` instead of something like a `div` as we\n  // do not want any events from the elements to trigger while we're parsing the\n  // template.\n  const template = document.createElement('template');\n\n  const lastHtmlStringIndex = htmlStrings.length - 1;\n\n  template.innerHTML = htmlStrings\n    .reduce((combinedHtmlStrings, htmlString, argIndex) => {\n      const htmlChunk = `${combinedHtmlStrings}${htmlString}`;\n      const arg = templateArgs[argIndex];\n      if (argIndex === lastHtmlStringIndex) {\n        return htmlChunk;\n      } else if (\n        typeof arg === 'string' ||\n        typeof arg === 'number' ||\n        typeof arg === 'boolean'\n      ) {\n        return `${htmlChunk}${arg}`;\n      } else if (arg instanceof Node) {\n        taggedArgs.set(argIndex, arg as Node);\n        return `${htmlChunk}${makeTaggedNode(argIndex)}`;\n      } else {\n        taggedArgs.set(argIndex, arg as ElementAttrs);\n        return `${htmlChunk}${makeTaggedAttr(argIndex)}`;\n      }\n    }, '')\n    // The combined HTML strings must be trimmed to remove meaningless\n    // whitespace characters. If not, given a string like this:\n    // h`\n    //   <p>Hello</p>\n    // `\n    // \"container.childNodes.length\" > 1 even though the only relevant node in\n    // that string is the \"div\" element.\n    .trim();\n\n  return {\n    template,\n    taggedArgs,\n  };\n};\n\n/**\n * Interpolate parsed HTML template literal with template literal arguments.\n * @param args Parsed and tagged HTML.\n */\nconst interpolate = ({\n  template,\n  taggedArgs,\n}: ReturnType<typeof parseAndTagArgs>): Node | DocumentFragment => {\n  const fragment = template.content.cloneNode(true) as DocumentFragment;\n\n  fragment.querySelectorAll(`[${TAGGED_ATTR_NAME}]`).forEach((node) => {\n    const argIndex = Number(node.getAttribute(TAGGED_ATTR_NAME) as string);\n    const arg = taggedArgs.get(argIndex) as Node | ElementAttrs;\n    if (arg instanceof Node) {\n      node.replaceWith(arg);\n    } else {\n      node.removeAttribute(TAGGED_ATTR_NAME);\n\n      Object.entries(arg).forEach(([attrName, attrValue]) => {\n        switch (attrName) {\n          case '$ref':\n            (attrValue as Required<ElementAttrs>['$ref'])(node);\n            break;\n          case 'style':\n            Object.entries(\n              attrValue as Required<ElementAttrs>['style']\n            ).forEach(([stylePropName, stylePropValue]) => {\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              node.style[stylePropName] = stylePropValue;\n            });\n            break;\n          case 'dataset':\n            Object.entries(\n              attrValue as Required<ElementAttrs>['dataset']\n            ).forEach(([dataPropName, dataPropValue]) => {\n              (node as HTMLElement).dataset[dataPropName] = dataPropValue;\n            });\n            break;\n          default:\n            if (typeof attrValue === 'string' && !(attrName in node)) {\n              node.setAttribute(attrName, attrValue);\n            } else {\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              node[attrName] = attrValue;\n            }\n        }\n      });\n    }\n  });\n\n  return fragment.childNodes.length === 1\n    ? (fragment.childNodes[0] as Node)\n    : fragment;\n};\n\n/**\n * Parse HTML template literal.\n * @param htmlStrings HTML template literal\n * @param templateArgs Interpolated HTML template literal values.\n */\nexport const h = (\n  htmlStrings: TemplateStringsArray,\n  ...templateArgs: (string | number | boolean | ElementAttrs | Node)[]\n): ReturnType<typeof interpolate> => {\n  return interpolate(parseAndTagArgs(htmlStrings, templateArgs));\n};\n"],
  "mappings": "AA8BA,MAAMA,EAAmB,mBAMnBC,EAAkBC,GAAsB,GAAGF,MAAqBE,KAMhEC,EAAkBD,GAAsB,MAAMD,EAAeC,CAAC,SAO9DE,EAAkB,CACtBC,EACAC,IAIG,CACH,MAAMC,EAA4B,IAAI,IAKhCC,EAAW,SAAS,cAAc,UAAU,EAE5CC,EAAsBJ,EAAY,OAAS,EAEjD,OAAAG,EAAS,UAAYH,EAClB,OAAO,CAACK,EAAqBC,EAAYC,IAAa,CACrD,MAAMC,EAAY,GAAGH,IAAsBC,IACrCG,EAAMR,EAAaM,CAAQ,EACjC,OAAIA,IAAaH,EACRI,EAEP,OAAOC,GAAQ,UACf,OAAOA,GAAQ,UACf,OAAOA,GAAQ,UAER,GAAGD,IAAYC,IACbA,aAAe,MACxBP,EAAW,IAAIK,EAAUE,CAAW,EAC7B,GAAGD,IAAYV,EAAeS,CAAQ,MAE7CL,EAAW,IAAIK,EAAUE,CAAmB,EACrC,GAAGD,IAAYZ,EAAeW,CAAQ,IAEjD,EAAG,EAAE,EAQJ,KAAK,EAED,CACL,SAAAJ,EACA,WAAAD,CACF,CACF,EAMMQ,EAAc,CAAC,CACnB,SAAAP,EACA,WAAAD,CACF,IAAmE,CACjE,MAAMS,EAAWR,EAAS,QAAQ,UAAU,EAAI,EAEhD,OAAAQ,EAAS,iBAAiB,IAAIhB,IAAmB,EAAE,QAASiB,GAAS,CACnE,MAAML,EAAW,OAAOK,EAAK,aAAajB,CAAgB,CAAW,EAC/Dc,EAAMP,EAAW,IAAIK,CAAQ,EAC/BE,aAAe,KACjBG,EAAK,YAAYH,CAAG,GAEpBG,EAAK,gBAAgBjB,CAAgB,EAErC,OAAO,QAAQc,CAAG,EAAE,QAAQ,CAAC,CAACI,EAAUC,CAAS,IAAM,CACrD,OAAQD,EAAU,CAChB,IAAK,OACFC,EAA6CF,CAAI,EAClD,MACF,IAAK,QACH,OAAO,QACLE,CACF,EAAE,QAAQ,CAAC,CAACC,EAAeC,CAAc,IAAM,CAG7CJ,EAAK,MAAMG,CAAa,EAAIC,CAC9B,CAAC,EACD,MACF,IAAK,UACH,OAAO,QACLF,CACF,EAAE,QAAQ,CAAC,CAACG,EAAcC,CAAa,IAAM,CAC1CN,EAAqB,QAAQK,CAAY,EAAIC,CAChD,CAAC,EACD,MACF,QACM,OAAOJ,GAAc,UAAY,EAAED,KAAYD,GACjDA,EAAK,aAAaC,EAAUC,CAAS,EAIrCF,EAAKC,CAAQ,EAAIC,CAEvB,CACF,CAAC,EAEL,CAAC,EAEMH,EAAS,WAAW,SAAW,EACjCA,EAAS,WAAW,CAAC,EACtBA,CACN,EAOaQ,EAAI,CACfnB,KACGC,IAEIS,EAAYX,EAAgBC,EAAaC,CAAY,CAAC",
  "names": ["TAGGED_ATTR_NAME", "makeTaggedAttr", "i", "makeTaggedNode", "parseAndTagArgs", "htmlStrings", "templateArgs", "taggedArgs", "template", "lastHtmlStringIndex", "combinedHtmlStrings", "htmlString", "argIndex", "htmlChunk", "arg", "interpolate", "fragment", "node", "attrName", "attrValue", "stylePropName", "stylePropValue", "dataPropName", "dataPropValue", "h"]
}
