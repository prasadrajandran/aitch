{
  "version": 3,
  "sources": ["../src/h.ts"],
  "sourcesContent": ["type ElementHeader = string;\n\ntype AttrNameKebabCase = string;\n\ntype AttrValue = string | number | boolean;\n\ntype DataAttrNameCamelCase = string;\n\ntype HChildNode = Node | string;\n\ntype ElementDetails<T extends HTMLElement> = {\n  $style?: Partial<CSSStyleDeclaration>;\n  $data?: Record<DataAttrNameCamelCase, AttrValue>;\n  $aria?: Record<AttrNameKebabCase, AttrValue>;\n  $ref?: (element: T) => void;\n  [attr: string]: unknown;\n};\n\n/**\n * Create an HTML Element.\n *\n * @param elementHeader Element header definition E.g. 'div',\n *   'div class=\"class\"', etc.\n * @param elementDetails Element details\n * @param nodes Child nodes.\n */\nexport const h = <T extends HTMLElement>(\n  elementHeader: ElementHeader,\n  elementDetails?: ElementDetails<T> | HChildNode,\n  ...nodes: HChildNode[]\n): T => {\n  const {\n    class: className = '',\n    id = '',\n    $style = {},\n    $data = {},\n    $aria = {},\n    $ref = () => {\n      /* Do nothing */\n    },\n    ...attrs\n  } = elementDetails instanceof Node || typeof elementDetails === 'string'\n    ? {}\n    : elementDetails || {};\n\n  const parser = document.createElement('div');\n  parser.innerHTML = `<${(elementHeader || '').trim()}/>`;\n  const element = parser.firstElementChild as T;\n\n  if (!element || element instanceof HTMLUnknownElement) {\n    throw new Error(`First argument to h() is invalid: \"${elementHeader}\"`);\n  }\n\n  if (element.childNodes.length) {\n    throw new Error(\n      'First argument to h() should not contain more than one element: ' +\n        parser.innerHTML\n    );\n  }\n\n  for (const [styleName, styleValue] of Object.entries($style)) {\n    if (typeof styleValue === 'string') {\n      // Note: Do not use \"style.setProperty\" because \"styleName\" is in\n      // camelCase.\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      element.style[styleName] = styleValue;\n    } else {\n      throw new Error(\n        `Value of \"${styleName}\" CSS style property has to be a string`\n      );\n    }\n  }\n\n  if (className) {\n    if (typeof className === 'string') {\n      element.classList.add(...className.split(' '));\n    } else {\n      throw new Error('Value of \"class\" attribute has to be a string');\n    }\n  }\n\n  if (id) {\n    if (typeof id === 'string') {\n      element.setAttribute('id', id);\n    } else {\n      throw new Error('Value of \"id\" attribute has to be a string');\n    }\n  }\n\n  for (const [attrName, attrValue] of Object.entries(attrs)) {\n    if (attrName.startsWith('on')) {\n      if (attrName in element) {\n        if (typeof attrValue === 'function') {\n          // eslint-disable-next-line\n          // @ts-ignore\n          element[attrName] = attrValue;\n        } else {\n          throw new Error(`Value of \"${attrName}\" has to be a function\"`);\n        }\n      } else {\n        throw new Error(\n          `\"${attrName}\" does not exist on \"${element.nodeName}\"`\n        );\n      }\n    } else {\n      if (typeof attrValue === 'string') {\n        element.setAttribute(attrName, attrValue);\n      } else {\n        throw new Error(`Value of \"${attrName}\" attribute has to be a string`);\n      }\n    }\n  }\n\n  for (const [dataAttrName, dataAttrValue] of Object.entries($data)) {\n    if (typeof dataAttrValue === 'string') {\n      element.dataset[dataAttrName] = dataAttrValue;\n    } else {\n      throw new Error(\n        `Value of \"${dataAttrName}\" data attribute has to be a string`\n      );\n    }\n  }\n\n  for (const [ariaAttrName, ariaAttrValue] of Object.entries($aria)) {\n    if (typeof ariaAttrValue === 'string') {\n      element.setAttribute(`aria-${ariaAttrName}`, ariaAttrValue);\n    } else {\n      throw new Error(\n        `Value of \"${ariaAttrName}\" ARIA attribute has to be a string`\n      );\n    }\n  }\n\n  if (elementDetails instanceof Node || typeof elementDetails === 'string') {\n    element.append(elementDetails);\n  }\n  element.append(...nodes);\n\n  $ref(element);\n\n  return element;\n};\n"],
  "mappings": "mRA0BO,MAAMA,EAAI,CACfC,EACAC,KACGC,IACG,CACN,MAUIC,EAAAF,aAA0B,MAAQ,OAAOA,GAAmB,SAC5D,CAAC,EACDA,GAAkB,CAAC,EAXrB,OAAOG,EAAY,GACnB,GAAAC,EAAK,GACL,OAAAC,EAAS,CAAC,EACV,MAAAC,EAAQ,CAAC,EACT,MAAAC,EAAQ,CAAC,EACT,KAAAC,EAAO,IAAM,CAEb,CAvCJ,EAyCMN,EADCO,EAAAC,EACDR,EADC,CARH,QACA,KACA,SACA,QACA,QACA,SAQIS,EAAS,SAAS,cAAc,KAAK,EAC3CA,EAAO,UAAY,KAAKZ,GAAiB,IAAI,KAAK,MAClD,MAAMa,EAAUD,EAAO,kBAEvB,GAAI,CAACC,GAAWA,aAAmB,mBACjC,MAAM,IAAI,MAAM,sCAAsCb,IAAgB,EAGxE,GAAIa,EAAQ,WAAW,OACrB,MAAM,IAAI,MACR,mEACED,EAAO,SACX,EAGF,SAAW,CAACE,EAAWC,CAAU,IAAK,OAAO,QAAQT,CAAM,EACzD,GAAI,OAAOS,GAAe,SAKxBF,EAAQ,MAAMC,GAAaC,MAE3B,OAAM,IAAI,MACR,aAAaD,0CACf,EAIJ,GAAIV,EACF,GAAI,OAAOA,GAAc,SACvBS,EAAQ,UAAU,IAAI,GAAGT,EAAU,MAAM,GAAG,CAAC,MAE7C,OAAM,IAAI,MAAM,+CAA+C,EAInE,GAAIC,EACF,GAAI,OAAOA,GAAO,SAChBQ,EAAQ,aAAa,KAAMR,CAAE,MAE7B,OAAM,IAAI,MAAM,4CAA4C,EAIhE,SAAW,CAACW,EAAUC,CAAS,IAAK,OAAO,QAAQP,CAAK,EACtD,GAAIM,EAAS,WAAW,IAAI,EAC1B,GAAIA,KAAYH,EACd,GAAI,OAAOI,GAAc,WAGvBJ,EAAQG,GAAYC,MAEpB,OAAM,IAAI,MAAM,aAAaD,0BAAiC,MAGhE,OAAM,IAAI,MACR,IAAIA,yBAAgCH,EAAQ,WAC9C,UAGE,OAAOI,GAAc,SACvBJ,EAAQ,aAAaG,EAAUC,CAAS,MAExC,OAAM,IAAI,MAAM,aAAaD,iCAAwC,EAK3E,SAAW,CAACE,EAAcC,CAAa,IAAK,OAAO,QAAQZ,CAAK,EAC9D,GAAI,OAAOY,GAAkB,SAC3BN,EAAQ,QAAQK,GAAgBC,MAEhC,OAAM,IAAI,MACR,aAAaD,sCACf,EAIJ,SAAW,CAACE,EAAcC,CAAa,IAAK,OAAO,QAAQb,CAAK,EAC9D,GAAI,OAAOa,GAAkB,SAC3BR,EAAQ,aAAa,QAAQO,IAAgBC,CAAa,MAE1D,OAAM,IAAI,MACR,aAAaD,sCACf,EAIJ,OAAInB,aAA0B,MAAQ,OAAOA,GAAmB,WAC9DY,EAAQ,OAAOZ,CAAc,EAE/BY,EAAQ,OAAO,GAAGX,CAAK,EAEvBO,EAAKI,CAAO,EAELA,CACT",
  "names": ["h", "elementHeader", "elementDetails", "nodes", "_a", "className", "id", "$style", "$data", "$aria", "$ref", "attrs", "__objRest", "parser", "element", "styleName", "styleValue", "attrName", "attrValue", "dataAttrName", "dataAttrValue", "ariaAttrName", "ariaAttrValue"]
}
