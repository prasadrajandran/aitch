{
  "version": 3,
  "sources": ["../src/h.ts"],
  "sourcesContent": ["type ElementAttrs = {\n  /**\n   * Obtain a reference to the instantiated Element with this callback.\n   * @param element\n   */\n  $ref?: (element: Element) => void;\n  /**\n   * CSS inline styles for the Element. The properties are expected to be in\n   * camelCase.\n   */\n  style?: Partial<CSSStyleDeclaration>;\n  /**\n   * A DOM string map of data attribute properties that will be attached to the\n   * element. The properties are expected to be in camelCase.\n   */\n  dataset?: HTMLOrSVGElement['dataset'];\n  /**\n   * Other miscellaneous attributes or properties that will be assigned to the\n   * Element.\n   */\n  [attr: string]: unknown;\n} & Partial<GlobalEventHandlers>;\n\ntype TemplateLiteralArgIndex = number;\n\ntype TaggedArgsMap = Map<TemplateLiteralArgIndex, Node | ElementAttrs>;\n\n/**\n * Template literal attribute/node argument attribute marker.\n */\nconst TAGGED_ATTR_NAME = 'data-FHF7Sj5kD1S';\n\n/**\n * Make a template literal attribute argument marker.\n * @param i Template literal argument index.\n */\nconst makeTaggedAttr = (i: number): string => `${TAGGED_ATTR_NAME}=\"${i}\"`;\n\n/**\n * Make a template literal node argument marker.\n * @param i Template literal argument index.\n */\nconst makeTaggedNode = (i: number): string => `<i ${makeTaggedAttr(i)}></i>`;\n\n/**\n * Parses HTML template literal and tags interpolated attributes and nodes.\n * @param htmlStrings Template literal HTML strings.\n * @param templateArgs Template literal interpolated values.\n */\nconst parseAndTagArgs = (\n  htmlStrings: TemplateStringsArray,\n  templateArgs: (string | number | boolean | ElementAttrs | Node)[]\n): {\n  template: HTMLTemplateElement;\n  taggedArgs: TaggedArgsMap;\n} => {\n  const taggedArgs: TaggedArgsMap = new Map();\n\n  // Intentionally using a `template` instead of something like a `div` as we\n  // do not want any events from the elements to trigger while we're parsing the\n  // template.\n  const template = document.createElement('template');\n\n  const lastHtmlStringIndex = htmlStrings.length - 1;\n\n  template.innerHTML = htmlStrings\n    .reduce((combinedHtmlStrings, htmlString, argIndex) => {\n      const htmlChunk = `${combinedHtmlStrings}${htmlString}`;\n      const arg = templateArgs[argIndex];\n      const argType = typeof arg;\n      // This check is meant to guard against honest mistakes not scenarios\n      // where the user is trying to intentionally pass a value off as a plain\n      // object, so it does not have to be exhaustive.\n      const isPlainObject =\n        arg &&\n        (arg.constructor === Object || Object.getPrototypeOf(arg) === null);\n      if (argIndex === lastHtmlStringIndex) {\n        return htmlChunk;\n      } else if (\n        argType === 'string' ||\n        argType === 'number' ||\n        argType === 'boolean'\n      ) {\n        return `${htmlChunk}${arg}`;\n      } else if (arg instanceof Node) {\n        taggedArgs.set(argIndex, arg as Node);\n        return `${htmlChunk}${makeTaggedNode(argIndex)}`;\n      } else if (isPlainObject) {\n        taggedArgs.set(argIndex, arg as ElementAttrs);\n        return `${htmlChunk}${makeTaggedAttr(argIndex)}`;\n      } else {\n        throw new Error(\n          `Invalid template argument at position ${argIndex} ` +\n            `(zero-based numbering)`\n        );\n      }\n    }, '')\n    // The combined HTML strings must be trimmed to remove meaningless\n    // whitespace characters. If not, given a string like this:\n    // h`\n    //   <p>Hello</p>\n    // `\n    // \"container.childNodes.length\" > 1 even though the only relevant node in\n    // that string is the \"div\" element.\n    .trim();\n\n  return {\n    template,\n    taggedArgs,\n  };\n};\n\n/**\n * Interpolate parsed HTML template literal with template literal arguments.\n * @param args Parsed and tagged HTML.\n */\nconst interpolate = ({\n  template,\n  taggedArgs,\n}: ReturnType<typeof parseAndTagArgs>): Node | DocumentFragment => {\n  const fragment = template.content.cloneNode(true) as DocumentFragment;\n\n  const processedTaggedArgs = new Set();\n  fragment.querySelectorAll(`[${TAGGED_ATTR_NAME}]`).forEach((node) => {\n    const argIndex = Number(node.getAttribute(TAGGED_ATTR_NAME) as string);\n    const arg = taggedArgs.get(argIndex) as Node | ElementAttrs;\n\n    // Note: not deleting processed values from `taggedArgs` even though that\n    // is easier because that introduces a side effect.\n    processedTaggedArgs.add(argIndex);\n\n    if (arg instanceof Node) {\n      node.replaceWith(arg);\n    } else {\n      node.removeAttribute(TAGGED_ATTR_NAME);\n\n      Object.entries(arg).forEach(([attrName, attrValue]) => {\n        switch (attrName) {\n          case '$ref':\n            (attrValue as Required<ElementAttrs>['$ref'])(node);\n            break;\n          case 'style':\n            Object.entries(\n              attrValue as Required<ElementAttrs>['style']\n            ).forEach(([stylePropName, stylePropValue]) => {\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              node.style[stylePropName] = stylePropValue;\n            });\n            break;\n          case 'dataset':\n            Object.entries(\n              attrValue as Required<ElementAttrs>['dataset']\n            ).forEach(([dataPropName, dataPropValue]) => {\n              (node as HTMLElement).dataset[dataPropName] = dataPropValue;\n            });\n            break;\n          default:\n            if (typeof attrValue === 'string' && !(attrName in node)) {\n              node.setAttribute(attrName, attrValue);\n            } else {\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              node[attrName] = attrValue;\n            }\n        }\n      });\n    }\n  });\n\n  if (processedTaggedArgs.size !== taggedArgs.size) {\n    const indices: number[] = [];\n    for (const argIndex of taggedArgs.keys()) {\n      if (!processedTaggedArgs.has(argIndex)) {\n        indices.push(argIndex);\n      }\n    }\n    const plural = indices.length > 1 ? 's' : '';\n    throw new Error(\n      `Unexpected template argument${plural} at position${plural} ${\n        '' + plural ? `[${indices.join(', ')}]` : indices[0]\n      } (zero-based numbering)`\n    );\n  }\n\n  return fragment.childNodes.length === 1\n    ? (fragment.childNodes[0] as Node)\n    : fragment;\n};\n\n/**\n * Parse HTML template literal.\n * @param htmlStrings HTML template literal\n * @param templateArgs Interpolated HTML template literal values.\n */\nexport const h = (\n  htmlStrings: TemplateStringsArray,\n  ...templateArgs: (string | number | boolean | ElementAttrs | Node)[]\n): ReturnType<typeof interpolate> => {\n  return interpolate(parseAndTagArgs(htmlStrings, templateArgs));\n};\n"],
  "mappings": "AA8BA,MAAMA,EAAmB,mBAMnBC,EAAkBC,GAAsB,GAAGF,MAAqBE,KAMhEC,EAAkBD,GAAsB,MAAMD,EAAeC,CAAC,SAO9DE,EAAkB,CACtBC,EACAC,IAIG,CACH,MAAMC,EAA4B,IAAI,IAKhCC,EAAW,SAAS,cAAc,UAAU,EAE5CC,EAAsBJ,EAAY,OAAS,EAEjD,OAAAG,EAAS,UAAYH,EAClB,OAAO,CAACK,EAAqBC,EAAYC,IAAa,CACrD,MAAMC,EAAY,GAAGH,IAAsBC,IACrCG,EAAMR,EAAaM,CAAQ,EAC3BG,EAAU,OAAOD,EAIjBE,EACJF,IACCA,EAAI,cAAgB,QAAU,OAAO,eAAeA,CAAG,IAAM,MAChE,GAAIF,IAAaH,EACf,OAAOI,EACF,GACLE,IAAY,UACZA,IAAY,UACZA,IAAY,UAEZ,MAAO,GAAGF,IAAYC,IACjB,GAAIA,aAAe,KACxB,OAAAP,EAAW,IAAIK,EAAUE,CAAW,EAC7B,GAAGD,IAAYV,EAAeS,CAAQ,IACxC,GAAII,EACT,OAAAT,EAAW,IAAIK,EAAUE,CAAmB,EACrC,GAAGD,IAAYZ,EAAeW,CAAQ,IAE7C,MAAM,IAAI,MACR,yCAAyCA,0BAE3C,CAEJ,EAAG,EAAE,EAQJ,KAAK,EAED,CACL,SAAAJ,EACA,WAAAD,CACF,CACF,EAMMU,EAAc,CAAC,CACnB,SAAAT,EACA,WAAAD,CACF,IAAmE,CACjE,MAAMW,EAAWV,EAAS,QAAQ,UAAU,EAAI,EAE1CW,EAAsB,IAAI,IAgDhC,GA/CAD,EAAS,iBAAiB,IAAIlB,IAAmB,EAAE,QAASoB,GAAS,CACnE,MAAMR,EAAW,OAAOQ,EAAK,aAAapB,CAAgB,CAAW,EAC/Dc,EAAMP,EAAW,IAAIK,CAAQ,EAInCO,EAAoB,IAAIP,CAAQ,EAE5BE,aAAe,KACjBM,EAAK,YAAYN,CAAG,GAEpBM,EAAK,gBAAgBpB,CAAgB,EAErC,OAAO,QAAQc,CAAG,EAAE,QAAQ,CAAC,CAACO,EAAUC,CAAS,IAAM,CACrD,OAAQD,EAAU,CAChB,IAAK,OACFC,EAA6CF,CAAI,EAClD,MACF,IAAK,QACH,OAAO,QACLE,CACF,EAAE,QAAQ,CAAC,CAACC,EAAeC,CAAc,IAAM,CAG7CJ,EAAK,MAAMG,CAAa,EAAIC,CAC9B,CAAC,EACD,MACF,IAAK,UACH,OAAO,QACLF,CACF,EAAE,QAAQ,CAAC,CAACG,EAAcC,CAAa,IAAM,CAC1CN,EAAqB,QAAQK,CAAY,EAAIC,CAChD,CAAC,EACD,MACF,QACM,OAAOJ,GAAc,UAAY,EAAED,KAAYD,GACjDA,EAAK,aAAaC,EAAUC,CAAS,EAIrCF,EAAKC,CAAQ,EAAIC,CAEvB,CACF,CAAC,EAEL,CAAC,EAEGH,EAAoB,OAASZ,EAAW,KAAM,CAChD,MAAMoB,EAAoB,CAAC,EAC3B,UAAWf,KAAYL,EAAW,KAAK,EAChCY,EAAoB,IAAIP,CAAQ,GACnCe,EAAQ,KAAKf,CAAQ,EAGzB,MAAMgB,EAASD,EAAQ,OAAS,EAAI,IAAM,GAC1C,MAAM,IAAI,MACR,+BAA+BC,gBAAqBA,KAClD,GAAKA,EAAS,IAAID,EAAQ,KAAK,IAAI,KAAOA,EAAQ,CAAC,0BAEvD,EAGF,OAAOT,EAAS,WAAW,SAAW,EACjCA,EAAS,WAAW,CAAC,EACtBA,CACN,EAOaW,EAAI,CACfxB,KACGC,IAEIW,EAAYb,EAAgBC,EAAaC,CAAY,CAAC",
  "names": ["TAGGED_ATTR_NAME", "makeTaggedAttr", "i", "makeTaggedNode", "parseAndTagArgs", "htmlStrings", "templateArgs", "taggedArgs", "template", "lastHtmlStringIndex", "combinedHtmlStrings", "htmlString", "argIndex", "htmlChunk", "arg", "argType", "isPlainObject", "interpolate", "fragment", "processedTaggedArgs", "node", "attrName", "attrValue", "stylePropName", "stylePropValue", "dataPropName", "dataPropValue", "indices", "plural", "h"]
}
