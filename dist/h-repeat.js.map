{
  "version": 3,
  "sources": ["../src/h-repeat.ts"],
  "sourcesContent": ["interface HRepeatElementCallbackParams<ITEM> {\n  key: unknown;\n  item: ITEM;\n  index: number;\n}\n\ninterface HRepeatRefCallbackParams<ITEM, ELEMENT>\n  extends HRepeatElementCallbackParams<ITEM> {\n  element: ELEMENT;\n}\n\ninterface HRepeatKeyCallback<ITEM> {\n  ({ key, item, index }: HRepeatElementCallbackParams<ITEM>): string;\n}\n\ninterface HRepeatElementCallback<ITEM, ELEMENT> {\n  ({ key, item, index }: HRepeatElementCallbackParams<ITEM>): ELEMENT;\n}\n\ninterface HRepeatRefCallback<ITEM, ELEMENT> {\n  ({ key, item, index }: HRepeatRefCallbackParams<ITEM, ELEMENT>): void;\n}\n\ninterface HRepeatOptions<ITEM> {\n  key?: HRepeatKeyCallback<ITEM>;\n  keyAttrName?: string;\n}\n\ninterface HRepeatParams<ITEM, ELEMENT extends Element> {\n  container: HTMLElement;\n  items:\n    | Map<unknown, ITEM>\n    | Set<ITEM>\n    | ITEM[]\n    | Record<string | number | symbol, ITEM>;\n  element: HRepeatElementCallback<ITEM, ELEMENT>;\n  ref?: HRepeatRefCallback<ITEM, ELEMENT>;\n  opts?: HRepeatOptions<ITEM>;\n}\n\n/**\n * Render a collection of nodes.\n */\nexport const hRepeat = <ITEM, ELEMENT extends Element>({\n  container,\n  items,\n  element: elementCallback,\n  ref,\n  opts = {},\n}: HRepeatParams<ITEM, ELEMENT>) => {\n  const keyAttrName = opts.keyAttrName || `data-h-repeat-key`;\n\n  const getKeyValue = opts.key || (({ key }) => key);\n\n  const entries = Array.isArray(items)\n    ? items.entries()\n    : items instanceof Map\n    ? items\n    : items instanceof Set\n    ? Array.from(items).entries()\n    : Object.entries(items);\n\n  const savedKeys = new Set<string>();\n\n  let index = 0;\n  for (const [key, item] of entries) {\n    const keyValue = String(getKeyValue({ key, item, index }));\n    savedKeys.add(keyValue);\n\n    let element = container.querySelector<ELEMENT>(\n      `[${keyAttrName}=\"${keyValue}\"]`\n    );\n    if (!element) {\n      element = elementCallback({ key, item, index });\n      element.setAttribute(keyAttrName, keyValue);\n      container.append(element);\n    }\n\n    if (ref && element) {\n      ref({ key, item, index, element });\n    }\n\n    index++;\n  }\n\n  container.querySelectorAll(`[${keyAttrName}]`).forEach((element) => {\n    if (!savedKeys.has(element.getAttribute(keyAttrName) as string)) {\n      element.remove();\n    }\n  });\n};\n"],
  "mappings": "AA2CO,MAAMA,EAAU,CAAgC,CACrD,UAAAC,EACA,MAAAC,EACA,QAASC,EACT,IAAAC,EACA,KAAAC,EAAO,CAAC,CACV,IAAoC,CAClC,MAAMC,EAAcD,EAAK,aAAe,oBAElCE,EAAcF,EAAK,MAAQ,CAAC,CAAE,IAAAG,CAAI,IAAMA,GAExCC,EAAU,MAAM,QAAQP,CAAK,EAC/BA,EAAM,QAAQ,EACdA,aAAiB,IACjBA,EACAA,aAAiB,IACjB,MAAM,KAAKA,CAAK,EAAE,QAAQ,EAC1B,OAAO,QAAQA,CAAK,EAElBQ,EAAY,IAAI,IAEtB,IAAIC,EAAQ,EACZ,SAAW,CAACH,EAAKI,CAAI,IAAKH,EAAS,CACjC,MAAMI,EAAW,OAAON,EAAY,CAAE,IAAAC,EAAK,KAAAI,EAAM,MAAAD,CAAM,CAAC,CAAC,EACzDD,EAAU,IAAIG,CAAQ,EAEtB,IAAIC,EAAUb,EAAU,cACtB,IAAIK,MAAgBO,KACtB,EACKC,IACHA,EAAUX,EAAgB,CAAE,IAAAK,EAAK,KAAAI,EAAM,MAAAD,CAAM,CAAC,EAC9CG,EAAQ,aAAaR,EAAaO,CAAQ,EAC1CZ,EAAU,OAAOa,CAAO,GAGtBV,GAAOU,GACTV,EAAI,CAAE,IAAAI,EAAK,KAAAI,EAAM,MAAAD,EAAO,QAAAG,CAAQ,CAAC,EAGnCH,GACF,CAEAV,EAAU,iBAAiB,IAAIK,IAAc,EAAE,QAASQ,GAAY,CAC7DJ,EAAU,IAAII,EAAQ,aAAaR,CAAW,CAAW,GAC5DQ,EAAQ,OAAO,CAEnB,CAAC,CACH",
  "names": ["hRepeat", "container", "items", "elementCallback", "ref", "opts", "keyAttrName", "getKeyValue", "key", "entries", "savedKeys", "index", "item", "keyValue", "element"]
}
